<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Norman vs. GOMS vs. KLM – Cognitive Models</title>

  <style>
  .row-norman { background-color: #fff3cd; }
  .row-goms   { background-color: #e7f3ff; }
  .row-klm    { background-color: #e9f7ef; }

  .design-focus { background-color: #e7f3ff; }

    

  .design-focus h3 {
    font-size: 1.1em;
  }

  
</style>

</head>
<body>

  <!-- Page header -->
  <header>
    <h1>Norman vs. GOMS vs. KLM</h1>
    <p>Model-based evaluation and cognitive models (Dix et al., Chapter 12)</p>
  </header>

  <!-- Primary navigation -->
  <nav aria-label="Primary navigation">
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="cv.html">CV</a></li>
      <li><a href="contact.html">Contact</a></li>
      <li><a href="analysis.html">Interaction Analysis</a></li>
      <li><a href="norman2klm.html" aria-current="page">Norman–GOMS–KLM</a></li>
      <li><a href="assignment01.html">Lab 01 Rules</a></li>

    </ul>
  </nav>

  <!-- Main content -->
  <main>

    <!-- Comparison section -->
    <section>
      <h2>Clean Comparison (Class &amp; Exam Reference)</h2>

      <table border="1">
        <caption>
          Model-based evaluation: what each model explains vs. predicts
        </caption>

        <thead>
          <tr>
            <th scope="col">Model</th>
            <th scope="col">Category</th>
            <th scope="col">What it Explains</th>
            <th scope="col">What it Predicts</th>
          </tr>
        </thead>

        <tbody>
          <tr class="row-norman">
            <th scope="row">Norman</th>
            <td>Cognitive / descriptive</td>
            <td>Understanding, errors, feedback, gulfs</td>
            <p>No quantitative performance prediction</p>
          </tr>

          <tr class="row-goms">
            <th scope="row">GOMS</th>
            <td>Predictive / analytic</td>
            <td>Task structure for expert users</td>
            <td>✔ Relative efficiency</td>
          </tr>

          <tr class="row-klm">
            <th scope="row">KLM</th>
            <td>Predictive / quantitative</td>
            <td>Low-level physical and motor actions</td>
            <td>✔ Execution time</td>
          </tr>
        </tbody>
      </table>
    </section>
      <section>
  <h2>Norman’s Stages</h2>

  <p>
    The interaction cycle can be divided into two major phases:
    <strong>execution</strong> and <strong>evaluation</strong>.
    These can then be subdivided into further stages, seven in all.
    The stages in Norman’s model of interaction are as follows:
  </p>

  <ol>
    <li>Establishing the goal.</li>
    <li>Forming the intention.</li>
    <li>Specifying the action sequence.</li>
    <li>Executing the action.</li>
    <li>Perceiving the system state.</li>
    <li>Interpreting the system state.</li>
    <li>
      Evaluating the system state with respect to the goals and intentions.
    </li>
  </ol>
</section>

      <section>
  <h2>GOMS</h2>

  <p>
    The GOMS model of Card, Moran and Newell is an acronym for
    <strong>Goals, Operators, Methods and Selection</strong> [56].
    A GOMS description consists of these four elements:
  </p>

  <p>
    <strong>Goals</strong>
    These are the user’s goals, describing what the user wants to achieve.
    Further, in GOMS the goals are taken to represent a ‘memory point’ for the user,
    from which he can evaluate what should be done and to which he may return
    should any errors occur.
  </p>

  <p>
    <strong>Operators</strong>
    These are the lowest level of analysis. They are the basic actions that the user
    must perform in order to use the system. They may affect the system
    (for example, press the ‘X’ key) or only the user’s mental state
    (for example, read the dialog box). There is still a degree of flexibility about
    the granularity of operators; we may take the command level ‘issue the SELECT command’
    or be more primitive: ‘move mouse to menu bar, press centre mouse button . . .’.
  </p>

  <p>
    <strong>Methods</strong>
    As we have already noted, there are typically several ways in which a goal can be
    split into subgoals. For instance, in a certain window manager a currently selected
    window can be closed to an icon either by selecting the ‘CLOSE’ option from a pop-up
    menu, or by hitting the ‘L7’ function key. In GOMS these two goal decompositions are
    referred to as methods, so we have the CLOSE-METHOD and the L7-METHOD:
  </p>

  <pre>
GOAL: ICONIZE-WINDOW
  . select GOAL: USE-CLOSE-METHOD
      . MOVE-MOUSE-TO-WINDOW-HEADER
      . POP-UP-MENU
      . CLICK-OVER-CLOSE-OPTION
  . GOAL: USE-L7-METHOD
      . PRESS-L7-KEY
  </pre>

  <p>
    The dots are used to indicate the hierarchical level of goals.
  </p>

  <p>
    <strong>Selection</strong>
    From the above snippet we see the use of the word select where the choice of methods
    arises. GOMS does not leave this as a random choice, but attempts to predict which
    methods will be used. This typically depends both on the particular user and on the
    state of the system and details about the goals. 
  </p>
</section>

  <section class="design-focus">
  <h2>Design Focus: GOMS Saves Money</h2>

  <p>
    GOMS is often used in industry not to improve usability directly,
    but to <strong>predict efficiency before systems are built</strong>.
    A well-known case described by Dix et al. involves the US telephone
    company NYNEX, which planned to install a new computer system for
    call operators. Before installation, a detailed GOMS analysis was
    performed, taking into account the cognitive and physical processes
    involved in handling a call. Because operators perform multiple
    activities in parallel, a PERT-style GOMS description was constructed
    to identify the critical path and estimate task completion time.
    The analysis revealed that the new system would actually
    <strong>increase call-handling time</strong> rather than reduce it.
    As a result, the system was abandoned before installation, saving
    the company millions of dollars. This example demonstrates how GOMS
    supports <strong>design decisions at an organizational level</strong>
    by predicting performance outcomes before costly implementation.
  </p>
</section>



    <!-- KLM operators -->
    <section>
      <h2>KLM Operators (Execution-Level Primitives)</h2>

      <p>
        The Keystroke-Level Model (KLM) decomposes the <strong>execution phase</strong>
        of interaction into a small set of primitive operators. KLM assumes the user
        is expert and that the method has already been chosen.
      </p>

      <table border="1">
        <caption>
          KLM operators (Dix et al., Chapter 12 – Cognitive Models / Physical &amp; Device Models)
        </caption>

        <thead>
          <tr>
            <th scope="col">Operator</th>
            <th scope="col">Name</th>
            <th scope="col">Meaning</th>
            <th scope="col">Example</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <th scope="row">K</th>
            <td>Keystroking</td>
            <td>Pressing a key (including modifiers)</td>
            <td>Typing a character or pressing Delete</td>
          </tr>

          <tr>
            <th scope="row">B</th>
            <td>Button press</td>
            <td>Pressing a mouse button</td>
            <td>Left-click</td>
          </tr>

          <tr>
            <th scope="row">P</th>
            <td>Pointing</td>
            <td>Moving pointer to a target</td>
            <td>Move cursor to an icon</td>
          </tr>

          <tr>
            <th scope="row">H</th>
            <td>Homing</td>
            <td>Switching hand between devices</td>
            <td>Keyboard → mouse</td>
          </tr>

          <tr>
            <th scope="row">D</th>
            <td>Drawing</td>
            <td>Drawing lines using a pointing device</td>
            <td>Dragging to draw a shape</td>
          </tr>

          <tr>
            <th scope="row">M</th>
            <td>Mental preparation</td>
            <td>Preparing for a physical action</td>
            <td>Pause before clicking the correct control</td>
          </tr>

          <tr>
            <th scope="row">R</th>
            <td>System response</td>
            <td>Waiting for system feedback (if required)</td>
            <td>Application loading</td>
          </tr>
        </tbody>
      </table>
    </section>

    <!-- Worked example -->
    <section>
      <h2>Worked Example: Correcting a Single Character</h2>

      <p>
        Example task: the user notices a single-character error in a mouse-based
        editor, deletes it, retypes it, and returns to the insertion point.
      </p>

      <ol>
        <li>Move hand to mouse</li>
        <li>Position mouse after bad character</li>
        <li>Return to keyboard</li>
        <li>Delete character</li>
        <li>Type correction</li>
        <li>Reposition insertion point</li>
      </ol>

      <p>One possible KLM operator sequence:</p>

      <pre>
H[mouse]
P B[LEFT]
H[keyboard]
M K[DELETE]
K[char]
H[mouse] M P B[LEFT]
      </pre>

      <p>
        This sequence illustrates how KLM models only execution-level actions.
        High-level planning, learning, and interpretation are not represented.
      </p>
    </section>

    <!-- Key takeaways -->
    <section>
      <h2>Key Takeaways</h2>

      <blockquote class="key-takeaway">
        <p>
          <strong>
            The Keystroke-Level Model consists of seven primitive operators
            (K, B, P, H, D, M, R) used to predict execution time for expert,
            error-free interaction, and is a low-level instance of the GOMS framework.
          </strong>
        </p>
      </blockquote>

      <blockquote class="key-takeaway">
        <p>
          <strong>
            KLM has only seven operators because it models execution,
            not thinking about what to do.
          </strong>
        </p>
      </blockquote>
    </section>

  </main>

  <!-- Footer -->
  <footer>
    <p><a href="index.html">Back to Home</a></p>
  </footer>

</body>
</html>
